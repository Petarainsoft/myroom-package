{"version":3,"file":"exrTextureLoader-DHmDgkaz.js","sources":["../node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.header.js","../node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.rle.js","../node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.compression.js","../node_modules/@babylonjs/core/Materials/Textures/Loaders/EXR/exrLoader.decoder.js","../node_modules/@babylonjs/core/Materials/Textures/Loaders/exrTextureLoader.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\nimport { Logger } from \"../../../../Misc/logger.js\";\nimport { ParseNullTerminatedString, ParseUint32, ParseValue } from \"./exrLoader.core.js\";\n/**\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\nconst EXR_MAGIC = 20000630;\n/**\n * Gets the EXR header\n * @param dataView defines the data view to read from\n * @param offset defines the offset to start reading from\n * @returns the header\n */\nexport function GetExrHeader(dataView, offset) {\n    if (dataView.getUint32(0, true) != EXR_MAGIC) {\n        throw new Error(\"Incorrect OpenEXR format\");\n    }\n    const version = dataView.getUint8(4);\n    const specData = dataView.getUint8(5); // fullMask\n    const spec = {\n        singleTile: !!(specData & 2),\n        longName: !!(specData & 4),\n        deepFormat: !!(specData & 8),\n        multiPart: !!(specData & 16),\n    };\n    offset.value = 8;\n    const headerData = {};\n    let keepReading = true;\n    while (keepReading) {\n        const attributeName = ParseNullTerminatedString(dataView.buffer, offset);\n        if (!attributeName) {\n            keepReading = false;\n        }\n        else {\n            const attributeType = ParseNullTerminatedString(dataView.buffer, offset);\n            const attributeSize = ParseUint32(dataView, offset);\n            const attributeValue = ParseValue(dataView, offset, attributeType, attributeSize);\n            if (attributeValue === undefined) {\n                Logger.Warn(`Unknown header attribute type ${attributeType}'.`);\n            }\n            else {\n                headerData[attributeName] = attributeValue;\n            }\n        }\n    }\n    if ((specData & ~0x04) != 0) {\n        throw new Error(\"Unsupported file format\");\n    }\n    return { version: version, spec: spec, ...headerData };\n}\n//# sourceMappingURL=exrLoader.header.js.map","/**\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n/** @internal */\nexport function DecodeRunLength(source) {\n    let size = source.byteLength;\n    const out = new Array();\n    let p = 0;\n    const reader = new DataView(source);\n    while (size > 0) {\n        const l = reader.getInt8(p++);\n        if (l < 0) {\n            const count = -l;\n            size -= count + 1;\n            for (let i = 0; i < count; i++) {\n                out.push(reader.getUint8(p++));\n            }\n        }\n        else {\n            const count = l;\n            size -= 2;\n            const value = reader.getUint8(p++);\n            for (let i = 0; i < count + 1; i++) {\n                out.push(value);\n            }\n        }\n    }\n    return out;\n}\n//# sourceMappingURL=exrLoader.compression.rle.js.map","import { ApplyLut, HufUncompress, ReverseLutFromBitmap, Wav2Decode } from \"./exrLoader.compression.huf.js\";\nimport { DecodeRunLength } from \"./exrLoader.compression.rle.js\";\nimport { InterleaveScalar, ParseUint16, ParseUint32, ParseUint8, Predictor } from \"./exrLoader.core.js\";\nimport { BITMAP_SIZE, INT16_SIZE, USHORT_RANGE } from \"./exrLoader.interfaces.js\";\n/**\n * No compression\n * @param decoder defines the decoder to use\n * @returns a decompressed data view\n */\nexport function UncompressRAW(decoder) {\n    return new DataView(decoder.array.buffer, decoder.offset.value, decoder.size);\n}\n/**\n * RLE compression\n * @param decoder defines the decoder to use\n * @returns a decompressed data view\n */\nexport function UncompressRLE(decoder) {\n    const compressed = decoder.viewer.buffer.slice(decoder.offset.value, decoder.offset.value + decoder.size);\n    const rawBuffer = new Uint8Array(DecodeRunLength(compressed));\n    const tmpBuffer = new Uint8Array(rawBuffer.length);\n    Predictor(rawBuffer);\n    InterleaveScalar(rawBuffer, tmpBuffer);\n    return new DataView(tmpBuffer.buffer);\n}\n/**\n * Zip compression\n * @param decoder defines the decoder to use\n * @returns a decompressed data view\n */\nexport function UncompressZIP(decoder) {\n    const compressed = decoder.array.slice(decoder.offset.value, decoder.offset.value + decoder.size);\n    const rawBuffer = fflate.unzlibSync(compressed);\n    const tmpBuffer = new Uint8Array(rawBuffer.length);\n    Predictor(rawBuffer);\n    InterleaveScalar(rawBuffer, tmpBuffer);\n    return new DataView(tmpBuffer.buffer);\n}\n/**\n * PXR compression\n * @param decoder defines the decoder to use\n * @returns a decompressed data view\n */\nexport function UncompressPXR(decoder) {\n    const compressed = decoder.array.slice(decoder.offset.value, decoder.offset.value + decoder.size);\n    const rawBuffer = fflate.unzlibSync(compressed);\n    const sz = decoder.lines * decoder.channels * decoder.width;\n    const tmpBuffer = decoder.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n    let tmpBufferEnd = 0;\n    let writePtr = 0;\n    const ptr = new Array(4);\n    for (let y = 0; y < decoder.lines; y++) {\n        for (let c = 0; c < decoder.channels; c++) {\n            let pixel = 0;\n            switch (decoder.type) {\n                case 1:\n                    ptr[0] = tmpBufferEnd;\n                    ptr[1] = ptr[0] + decoder.width;\n                    tmpBufferEnd = ptr[1] + decoder.width;\n                    for (let j = 0; j < decoder.width; ++j) {\n                        const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++];\n                        pixel += diff;\n                        tmpBuffer[writePtr] = pixel;\n                        writePtr++;\n                    }\n                    break;\n                case 2:\n                    ptr[0] = tmpBufferEnd;\n                    ptr[1] = ptr[0] + decoder.width;\n                    ptr[2] = ptr[1] + decoder.width;\n                    tmpBufferEnd = ptr[2] + decoder.width;\n                    for (let j = 0; j < decoder.width; ++j) {\n                        const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8);\n                        pixel += diff;\n                        tmpBuffer[writePtr] = pixel;\n                        writePtr++;\n                    }\n                    break;\n            }\n        }\n    }\n    return new DataView(tmpBuffer.buffer);\n}\n/**\n * PIZ compression\n * @param decoder defines the decoder to use\n * @returns a decompressed data view\n */\nexport function UncompressPIZ(decoder) {\n    const inDataView = decoder.viewer;\n    const inOffset = { value: decoder.offset.value };\n    const outBuffer = new Uint16Array(decoder.width * decoder.scanlineBlockSize * (decoder.channels * decoder.type));\n    const bitmap = new Uint8Array(BITMAP_SIZE);\n    // Setup channel info\n    let outBufferEnd = 0;\n    const pizChannelData = new Array(decoder.channels);\n    for (let i = 0; i < decoder.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = decoder.width;\n        pizChannelData[i][\"ny\"] = decoder.lines;\n        pizChannelData[i][\"size\"] = decoder.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n    }\n    // Read range compression data\n    const minNonZero = ParseUint16(inDataView, inOffset);\n    const maxNonZero = ParseUint16(inDataView, inOffset);\n    if (maxNonZero >= BITMAP_SIZE) {\n        throw new Error(\"Wrong PIZ_COMPRESSION BITMAP_SIZE\");\n    }\n    if (minNonZero <= maxNonZero) {\n        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {\n            bitmap[i + minNonZero] = ParseUint8(inDataView, inOffset);\n        }\n    }\n    // Reverse LUT\n    const lut = new Uint16Array(USHORT_RANGE);\n    const maxValue = ReverseLutFromBitmap(bitmap, lut);\n    const length = ParseUint32(inDataView, inOffset);\n    // Huffman decoding\n    HufUncompress(decoder.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n    // Wavelet decoding\n    for (let i = 0; i < decoder.channels; ++i) {\n        const cd = pizChannelData[i];\n        for (let j = 0; j < pizChannelData[i].size; ++j) {\n            Wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n    }\n    // Expand the pixel data to their original range\n    ApplyLut(lut, outBuffer, outBufferEnd);\n    // Rearrange the pixel data into the format expected by the caller.\n    let tmpOffset = 0;\n    const tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n    for (let y = 0; y < decoder.lines; y++) {\n        for (let c = 0; c < decoder.channels; c++) {\n            const cd = pizChannelData[c];\n            const n = cd.nx * cd.size;\n            const cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n            tmpBuffer.set(cp, tmpOffset);\n            tmpOffset += n * INT16_SIZE;\n            cd.end += n;\n        }\n    }\n    return new DataView(tmpBuffer.buffer);\n}\n//# sourceMappingURL=exrLoader.compression.js.map","import { CompressionCodes, DecodeFloat32, ParseFloat16, ParseFloat32, ParseInt32, ParseInt64, ParseUint16, ParseUint32 } from \"./exrLoader.core.js\";\nimport { UncompressPIZ, UncompressPXR, UncompressRAW, UncompressRLE, UncompressZIP } from \"./exrLoader.compression.js\";\nimport { FLOAT32_SIZE, INT16_SIZE } from \"./exrLoader.interfaces.js\";\n\nimport { Tools } from \"../../../../Misc/tools.js\";\nimport { ExrLoaderGlobalConfiguration, EXROutputType } from \"./exrLoader.configuration.js\";\n/**\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n/**\n * Create a decoder for the exr file\n * @param header header of the exr file\n * @param dataView dataview of the exr file\n * @param offset current offset\n * @param outputType expected output type (float or half float)\n * @returns a promise that resolves with the decoder\n */\nexport async function CreateDecoderAsync(header, dataView, offset, outputType) {\n    const decoder = {\n        size: 0,\n        viewer: dataView,\n        array: new Uint8Array(dataView.buffer),\n        offset: offset,\n        width: header.dataWindow.xMax - header.dataWindow.xMin + 1,\n        height: header.dataWindow.yMax - header.dataWindow.yMin + 1,\n        channels: header.channels.length,\n        channelLineOffsets: {},\n        scanOrder: () => 0,\n        bytesPerLine: 0,\n        outLineWidth: 0,\n        lines: 0,\n        scanlineBlockSize: 0,\n        inputSize: null,\n        type: 0,\n        uncompress: null,\n        getter: () => 0,\n        format: 5,\n        outputChannels: 0,\n        decodeChannels: {},\n        blockCount: null,\n        byteArray: null,\n        linearSpace: false,\n        textureType: 0,\n    };\n    switch (header.compression) {\n        case CompressionCodes.NO_COMPRESSION:\n            decoder.lines = 1;\n            decoder.uncompress = UncompressRAW;\n            break;\n        case CompressionCodes.RLE_COMPRESSION:\n            decoder.lines = 1;\n            decoder.uncompress = UncompressRLE;\n            break;\n        case CompressionCodes.ZIPS_COMPRESSION:\n            decoder.lines = 1;\n            decoder.uncompress = UncompressZIP;\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\n            break;\n        case CompressionCodes.ZIP_COMPRESSION:\n            decoder.lines = 16;\n            decoder.uncompress = UncompressZIP;\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\n            break;\n        case CompressionCodes.PIZ_COMPRESSION:\n            decoder.lines = 32;\n            decoder.uncompress = UncompressPIZ;\n            break;\n        case CompressionCodes.PXR24_COMPRESSION:\n            decoder.lines = 16;\n            decoder.uncompress = UncompressPXR;\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\n            break;\n        default:\n            throw new Error(CompressionCodes[header.compression] + \" is unsupported\");\n    }\n    decoder.scanlineBlockSize = decoder.lines;\n    const channels = {};\n    for (const channel of header.channels) {\n        switch (channel.name) {\n            case \"Y\":\n            case \"R\":\n            case \"G\":\n            case \"B\":\n            case \"A\":\n                channels[channel.name] = true;\n                decoder.type = channel.pixelType;\n        }\n    }\n    // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n    let fillAlpha = false;\n    if (channels.R && channels.G && channels.B) {\n        fillAlpha = !channels.A;\n        decoder.outputChannels = 4;\n        decoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };\n    }\n    else if (channels.Y) {\n        decoder.outputChannels = 1;\n        decoder.decodeChannels = { Y: 0 };\n    }\n    else {\n        throw new Error(\"EXRLoader.parse: file contains unsupported data channels.\");\n    }\n    if (decoder.type === 1) {\n        // half\n        switch (outputType) {\n            case EXROutputType.Float:\n                decoder.getter = ParseFloat16;\n                decoder.inputSize = INT16_SIZE;\n                break;\n            case EXROutputType.HalfFloat:\n                decoder.getter = ParseUint16;\n                decoder.inputSize = INT16_SIZE;\n                break;\n        }\n    }\n    else if (decoder.type === 2) {\n        // float\n        switch (outputType) {\n            case EXROutputType.Float:\n                decoder.getter = ParseFloat32;\n                decoder.inputSize = FLOAT32_SIZE;\n                break;\n            case EXROutputType.HalfFloat:\n                decoder.getter = DecodeFloat32;\n                decoder.inputSize = FLOAT32_SIZE;\n        }\n    }\n    else {\n        throw new Error(\"Unsupported pixelType \" + decoder.type + \" for \" + header.compression);\n    }\n    decoder.blockCount = decoder.height / decoder.scanlineBlockSize;\n    for (let i = 0; i < decoder.blockCount; i++) {\n        ParseInt64(dataView, offset); // scanlineOffset\n    }\n    // we should be passed the scanline offset table, ready to start reading pixel data.\n    const size = decoder.width * decoder.height * decoder.outputChannels;\n    switch (outputType) {\n        case EXROutputType.Float:\n            decoder.byteArray = new Float32Array(size);\n            decoder.textureType = 1;\n            // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n            if (fillAlpha) {\n                decoder.byteArray.fill(1, 0, size);\n            }\n            break;\n        case EXROutputType.HalfFloat:\n            decoder.byteArray = new Uint16Array(size);\n            decoder.textureType = 2;\n            if (fillAlpha) {\n                decoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\n            }\n            break;\n        default:\n            throw new Error(\"Unsupported type: \" + outputType);\n    }\n    let byteOffset = 0;\n    for (const channel of header.channels) {\n        if (decoder.decodeChannels[channel.name] !== undefined) {\n            decoder.channelLineOffsets[channel.name] = byteOffset * decoder.width;\n        }\n        byteOffset += channel.pixelType * 2;\n    }\n    decoder.bytesPerLine = decoder.width * byteOffset;\n    decoder.outLineWidth = decoder.width * decoder.outputChannels;\n    if (header.lineOrder === \"INCREASING_Y\") {\n        decoder.scanOrder = (y) => y;\n    }\n    else {\n        decoder.scanOrder = (y) => decoder.height - 1 - y;\n    }\n    if (decoder.outputChannels == 4) {\n        decoder.format = 5;\n        decoder.linearSpace = true;\n    }\n    else {\n        decoder.format = 6;\n        decoder.linearSpace = false;\n    }\n    return decoder;\n}\n/**\n * Scan the data of the exr file\n * @param decoder decoder to use\n * @param header header of the exr file\n * @param dataView dataview of the exr file\n * @param offset current offset\n */\nexport function ScanData(decoder, header, dataView, offset) {\n    const tmpOffset = { value: 0 };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < decoder.height / decoder.scanlineBlockSize; scanlineBlockIdx++) {\n        const line = ParseInt32(dataView, offset) - header.dataWindow.yMin; // line_no\n        decoder.size = ParseUint32(dataView, offset); // data_len\n        decoder.lines = line + decoder.scanlineBlockSize > decoder.height ? decoder.height - line : decoder.scanlineBlockSize;\n        const isCompressed = decoder.size < decoder.lines * decoder.bytesPerLine;\n        const viewer = isCompressed && decoder.uncompress ? decoder.uncompress(decoder) : UncompressRAW(decoder);\n        offset.value += decoder.size;\n        for (let line_y = 0; line_y < decoder.scanlineBlockSize; line_y++) {\n            const scan_y = scanlineBlockIdx * decoder.scanlineBlockSize;\n            const true_y = line_y + decoder.scanOrder(scan_y);\n            if (true_y >= decoder.height) {\n                continue;\n            }\n            const lineOffset = line_y * decoder.bytesPerLine;\n            const outLineOffset = (decoder.height - 1 - true_y) * decoder.outLineWidth;\n            for (let channelID = 0; channelID < decoder.channels; channelID++) {\n                const name = header.channels[channelID].name;\n                const lOff = decoder.channelLineOffsets[name];\n                const cOff = decoder.decodeChannels[name];\n                if (cOff === undefined) {\n                    continue;\n                }\n                tmpOffset.value = lineOffset + lOff;\n                for (let x = 0; x < decoder.width; x++) {\n                    const outIndex = outLineOffset + x * decoder.outputChannels + cOff;\n                    if (decoder.byteArray) {\n                        decoder.byteArray[outIndex] = decoder.getter(viewer, tmpOffset);\n                    }\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=exrLoader.decoder.js.map","import { GetExrHeader } from \"./EXR/exrLoader.header.js\";\nimport { CreateDecoderAsync, ScanData } from \"./EXR/exrLoader.decoder.js\";\nimport { ExrLoaderGlobalConfiguration } from \"./EXR/exrLoader.configuration.js\";\n/**\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation.\n */\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n// // End of OpenEXR license -------------------------------------------------\n/**\n * Loader for .exr file format\n * @see [PIZ compression](https://playground.babylonjs.com/#4RN0VF#151)\n * @see [ZIP compression](https://playground.babylonjs.com/#4RN0VF#146)\n * @see [RLE compression](https://playground.babylonjs.com/#4RN0VF#149)\n * @see [PXR24 compression](https://playground.babylonjs.com/#4RN0VF#150)\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _ExrTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     * @param _data contains the texture data\n     * @param _texture defines the BabylonJS internal texture\n     * @param _createPolynomials will be true if polynomials have been requested\n     * @param _onLoad defines the callback to trigger once the texture is ready\n     * @param _onError defines the callback to trigger in case of error\n     * Cube texture are not supported by .exr files\n     */\n    loadCubeData(_data, _texture, _createPolynomials, _onLoad, _onError) {\n        // eslint-disable-next-line no-throw-literal\n        throw \".exr not supported in Cube.\";\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     */\n    async loadData(data, texture, callback) {\n        const dataView = new DataView(data.buffer);\n        const offset = { value: 0 };\n        const header = GetExrHeader(dataView, offset);\n        const decoder = await CreateDecoderAsync(header, dataView, offset, ExrLoaderGlobalConfiguration.DefaultOutputType);\n        ScanData(decoder, header, dataView, offset);\n        // Updating texture\n        const width = header.dataWindow.xMax - header.dataWindow.xMin + 1;\n        const height = header.dataWindow.yMax - header.dataWindow.yMin + 1;\n        callback(width, height, texture.generateMipMaps, false, () => {\n            const engine = texture.getEngine();\n            texture.format = header.format;\n            texture.type = decoder.textureType;\n            texture.invertY = false;\n            texture._gammaSpace = !header.linearSpace;\n            if (decoder.byteArray) {\n                engine._uploadDataToTextureDirectly(texture, decoder.byteArray, 0, 0, undefined, true);\n            }\n        });\n    }\n}\n//# sourceMappingURL=exrTextureLoader.js.map"],"names":["EXR_MAGIC","GetExrHeader","dataView","offset","version","specData","spec","headerData","keepReading","attributeName","ParseNullTerminatedString","attributeType","attributeSize","ParseUint32","attributeValue","ParseValue","Logger","__spreadValues","DecodeRunLength","source","size","out","p","reader","count","value","i","UncompressRAW","decoder","UncompressRLE","compressed","rawBuffer","tmpBuffer","Predictor","InterleaveScalar","UncompressZIP","UncompressPXR","sz","tmpBufferEnd","writePtr","ptr","y","c","pixel","j","diff","UncompressPIZ","inDataView","inOffset","outBuffer","bitmap","BITMAP_SIZE","outBufferEnd","pizChannelData","minNonZero","ParseUint16","maxNonZero","ParseUint8","lut","USHORT_RANGE","maxValue","ReverseLutFromBitmap","length","HufUncompress","cd","Wav2Decode","ApplyLut","tmpOffset","n","cp","INT16_SIZE","CreateDecoderAsync","header","outputType","__async","CompressionCodes","Tools","ExrLoaderGlobalConfiguration","channels","channel","fillAlpha","EXROutputType","ParseFloat16","ParseFloat32","FLOAT32_SIZE","DecodeFloat32","ParseInt64","byteOffset","ScanData","scanlineBlockIdx","line","ParseInt32","viewer","line_y","scan_y","true_y","lineOffset","outLineOffset","channelID","name","lOff","cOff","x","outIndex","_ExrTextureLoader","_data","_texture","_createPolynomials","_onLoad","_onError","data","texture","callback","width","height","engine"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}