{"version":3,"file":"basisTextureLoader-z5qarHjG.js","sources":["../node_modules/@babylonjs/core/Materials/Textures/Loaders/basisTextureLoader.js"],"sourcesContent":["import { LoadTextureFromTranscodeResult, TranscodeAsync } from \"../../../Misc/basis.js\";\nimport { Tools } from \"../../../Misc/tools.js\";\n/**\n * Loader for .basis file format\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _BasisTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param createPolynomials will be true if polynomials have been requested\n     * @param onLoad defines the callback to trigger once the texture is ready\n     * @param onError defines the callback to trigger in case of error\n     */\n    loadCubeData(data, texture, createPolynomials, onLoad, onError) {\n        if (Array.isArray(data)) {\n            return;\n        }\n        const caps = texture.getEngine().getCaps();\n        const transcodeConfig = {\n            supportedCompressionFormats: {\n                etc1: caps.etc1 ? true : false,\n                s3tc: caps.s3tc ? true : false,\n                pvrtc: caps.pvrtc ? true : false,\n                etc2: caps.etc2 ? true : false,\n                astc: caps.astc ? true : false,\n                bc7: caps.bptc ? true : false,\n            },\n        };\n        TranscodeAsync(data, transcodeConfig)\n            .then((result) => {\n            const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\n            LoadTextureFromTranscodeResult(texture, result);\n            texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);\n            texture.isReady = true;\n            texture.onLoadedObservable.notifyObservers(texture);\n            texture.onLoadedObservable.clear();\n            if (onLoad) {\n                onLoad();\n            }\n        })\n            .catch((err) => {\n            const errorMessage = \"Failed to transcode Basis file, transcoding may not be supported on this device\";\n            Tools.Warn(errorMessage);\n            texture.isReady = true;\n            if (onError) {\n                onError(err);\n            }\n        });\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     */\n    loadData(data, texture, callback) {\n        const caps = texture.getEngine().getCaps();\n        const transcodeConfig = {\n            supportedCompressionFormats: {\n                etc1: caps.etc1 ? true : false,\n                s3tc: caps.s3tc ? true : false,\n                pvrtc: caps.pvrtc ? true : false,\n                etc2: caps.etc2 ? true : false,\n                astc: caps.astc ? true : false,\n                bc7: caps.bptc ? true : false,\n            },\n        };\n        TranscodeAsync(data, transcodeConfig)\n            .then((result) => {\n            const rootImage = result.fileInfo.images[0].levels[0];\n            const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\n            callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {\n                LoadTextureFromTranscodeResult(texture, result);\n            });\n        })\n            .catch((err) => {\n            Tools.Warn(\"Failed to transcode Basis file, transcoding may not be supported on this device\");\n            Tools.Warn(`Failed to transcode Basis file: ${err}`);\n            callback(0, 0, false, false, () => { }, true);\n        });\n    }\n}\n//# sourceMappingURL=basisTextureLoader.js.map"],"names":["_BasisTextureLoader","data","texture","createPolynomials","onLoad","onError","caps","transcodeConfig","TranscodeAsync","result","hasMipmap","LoadTextureFromTranscodeResult","err","Tools","callback","rootImage"],"mappings":";AAOO,MAAMA,EAAoB;AAAA,EAC7B,cAAc;AAIV,SAAK,kBAAkB;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASI,aAAaC,GAAMC,GAASC,GAAmBC,GAAQC,GAAS;AAC5D,QAAI,MAAM,QAAQJ,CAAI;AAClB;AAEJ,UAAMK,IAAOJ,EAAQ,UAAS,EAAG,QAAS,GACpCK,IAAkB;AAAA,MACpB,6BAA6B;AAAA,QACzB,MAAM,EAAAD,EAAK;AAAA,QACX,MAAM,EAAAA,EAAK;AAAA,QACX,OAAO,EAAAA,EAAK;AAAA,QACZ,MAAM,EAAAA,EAAK;AAAA,QACX,MAAM,EAAAA,EAAK;AAAA,QACX,KAAK,EAAAA,EAAK;AAAA,MACb;AAAA,IACJ;AACD,IAAAE,EAAeP,GAAMM,CAAe,EAC/B,KAAK,CAACE,MAAW;AAClB,YAAMC,IAAYD,EAAO,SAAS,OAAO,CAAC,EAAE,OAAO,SAAS,KAAKP,EAAQ;AACzE,MAAAS,EAA+BT,GAASO,CAAM,GAC9CP,EAAQ,UAAW,EAAC,yBAAyBA,GAASQ,CAAS,GAC/DR,EAAQ,UAAU,IAClBA,EAAQ,mBAAmB,gBAAgBA,CAAO,GAClDA,EAAQ,mBAAmB,MAAO,GAC9BE,KACAA,EAAQ;AAAA,IAEf,CAAA,EACI,MAAM,CAACQ,MAAQ;AAEhB,MAAAC,EAAM,KADe,iFACE,GACvBX,EAAQ,UAAU,IACdG,KACAA,EAAQO,CAAG;AAAA,IAE3B,CAAS;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOI,SAASX,GAAMC,GAASY,GAAU;AAC9B,UAAMR,IAAOJ,EAAQ,UAAS,EAAG,QAAS,GACpCK,IAAkB;AAAA,MACpB,6BAA6B;AAAA,QACzB,MAAM,EAAAD,EAAK;AAAA,QACX,MAAM,EAAAA,EAAK;AAAA,QACX,OAAO,EAAAA,EAAK;AAAA,QACZ,MAAM,EAAAA,EAAK;AAAA,QACX,MAAM,EAAAA,EAAK;AAAA,QACX,KAAK,EAAAA,EAAK;AAAA,MACb;AAAA,IACJ;AACD,IAAAE,EAAeP,GAAMM,CAAe,EAC/B,KAAK,CAACE,MAAW;AAClB,YAAMM,IAAYN,EAAO,SAAS,OAAO,CAAC,EAAE,OAAO,CAAC,GAC9CC,IAAYD,EAAO,SAAS,OAAO,CAAC,EAAE,OAAO,SAAS,KAAKP,EAAQ;AACzE,MAAAY,EAASC,EAAU,OAAOA,EAAU,QAAQL,GAAWD,EAAO,WAAW,IAAI,MAAM;AAC/E,QAAAE,EAA+BT,GAASO,CAAM;AAAA,MAC9D,CAAa;AAAA,IACJ,CAAA,EACI,MAAM,CAACG,MAAQ;AAChB,MAAAC,EAAM,KAAK,iFAAiF,GAC5FA,EAAM,KAAK,mCAAmCD,CAAG,EAAE,GACnDE,EAAS,GAAG,GAAG,IAAO,IAAO,MAAM;AAAA,MAAG,GAAE,EAAI;AAAA,IACxD,CAAS;AAAA,EACT;AACA;","x_google_ignoreList":[0]}